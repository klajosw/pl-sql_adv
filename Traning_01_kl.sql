/* ---
SELECT
    empno,
    ename,
    job,
    mgr,
    hiredate,
    sal,
    comm,
    deptno
FROM
    scott.emp e order by e.sal desc --offset 1 rows  fetch next 5 rows only
    offset 0 rows fetch next 2 rows with ties;
    */
----
create or replace function scott.topnsal(p_n number) return  number is 
   l_sum number(10,2);
begin
-- tanfolyamra készítet KL
 SELECT  SUM(sal) into l_sum from(
  SELECT * FROM  scott.emp e order by e.sal desc 
  offset 0 rows  fetch next p_n rows only );
  return l_sum;
End topnsal;
/
select scott.topnsal(3) FROM DUAL;

select scott.topnsal(3) FROM DUAL;

create or replace procedure scott.topnsal_caller is
begin
 dbms_output.put_line(scott.topnsal(10));
end topnsal_caller;
/
begin
   scott.topnsal_caller;
end;
---
select * from all_objects where owner ='SCOTT' and OBJECT_TYPE in ('FUNCTION', 'PROCEDURE')
---
alter procedure scott.topnsal_caller compile;
---
alter session set plsql_warnings='ENABLE:ALL';
---
select * from all_plsql_object_settings where owner ='SCOTT'
---
select * from all_identifiers where owner ='SCOTT'
--  
select * from all_statements where owner ='SCOTT'
---
select * from all_dependencies  where owner ='SCOTT'
---
update oe.orders o
  set order_total =    
  (select sum(oi.quantity + oi.unit_price) from oe.order_items oi where oi.order_id = o.order_id)
  where o.order_id=2458;
---
   
  
---java

create java source named FileHelper as
import java.io.File;
public class FileHelper {
  public static String dirList(String dir) {
    File f = null;
    String[] paths;
    String dirlist = new String();
    try {    
      f = new File(dir);
      paths = f.list();
      for(String path:paths) {
        dirlist = dirlist + ":" + path;
      }
    } catch(Exception e) {
        dirlist = e.toString();
    }      
    return dirlist;
  } 
}

/
alter java class "FileHelper" RESOLVE;
---
select * from all_objects where object_name like '%FileHelper%'
---
create or replace function directorli_list(p_dir varchar2) return varchar2 is language JAVA
Name 'FileHelper.dirList(java.lang.String) return java.lang.String';

---

select directorli_list('C:\Installs') from dual;

---- 
CREATE DIRECTORY javaext_dir as 'C:\Installs\PLS3_Java';
select * from all_directories;
create java class using bfile (javaext_dir, 'WebHelper.class')

---
select * from all_objects where object_name like '%WebHelper%'
alter java class "WebHelper" RESOLVE;
---
create or replace function getURL(p_url varchar2, p_start number, p_end number)
return varchar2 is language JAVA name 'WebHelper.getURL(java.lang.String, int, int) return java.lang.String';

select getURL('http://mnbkozeparfolyam.hu', 0, 1000) from dual;


 
 C:\Oracle\oradata\TRAININGGLOB\training
/
CREATE TABLESPACE tbs_lob DATAFILE 'C:\Oracle\oradata\TRAININGGLOB\training\tbl_lob.DBF'
size 100M SEGMENT SPACE MANAGEMENT AUTO;


create table exercises (
ID number(6) generated by default as identity not null,
File varchar2(100) not null,
content clob not null)
LOB (content) store as SECUREFILE (TABLESPACE tbs_lob COMPRESS HIGH DEDUPLICATE);


CREATE TABLE exercises (
    id          NUMBER(6)       GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    filename    VARCHAR2(100)   NOT NULL,
    content     CLOB            NOT NULL)
LOB(content) STORE AS SECUREFILE(TABLESPACE tbs_lob COMPRESS HIGH DEDUPLICATE);

create directory exercises_dir as 'c:\Student\Exercises';

DECLARE
    l_dest_offset INTEGER;    l_src_offset INTEGER;
    l_warning INTEGER;        l_lang_context INTEGER;
    l_exf BFILE;              l_tempc CLOB;
    CURSOR cfiles IS
        SELECT COLUMN_VALUE FROM split(DIRECTORLI_LIST('C:\Student\Exercises'), ':');
BEGIN
    FOR rfiles IN cfiles LOOP
        DBMS_OUTPUT.PUT_LINE(rfiles.COLUMN_VALUE);
        IF UPPER(rfiles.COLUMN_VALUE) LIKE '%.SQL' THEN
            l_exf := BFILENAME('exercises_dir', rfiles.COLUMN_VALUE);    
            DBMS_LOB.OPEN(l_exf, DBMS_LOB.FILE_READONLY);
            IF DBMS_LOB.GETLENGTH(l_exf) > 0 THEN --ne adjon hibát üres betöltésnél
                DBMS_LOB.CREATETEMPORARY(l_tempc, TRUE);
                l_src_offset := 1; l_dest_offset := 1;
                l_lang_context := 0; l_warning := 0;
                DBMS_LOB.LOADCLOBFROMFILE(l_tempc, l_exf, DBMS_LOB.LOBMAXSIZE, 
                    l_dest_offset, l_src_offset, 0, l_lang_context, l_warning);
                INSERT INTO exercises (filename, content)
                VALUES (rfiles.COLUMN_VALUE, l_tempc);
                DBMS_LOB.FREETEMPORARY(l_tempc);
            END IF;    
            DBMS_LOB.CLOSE(l_exf);
        END IF;
    END LOOP;
END;
/
SELECT * FROM exercises;

---select * from all_objects where object_name LIKE '%DIREC%'

---particionálás

create table OE.orders_listpart
partition by list (order_mode) automatic
(partition order_mode_direct values ('direct'),
 partition order_mode_online values ('online'))
as select * from OE.orders
;
SELECT ORA_HASH(e.ename), e.ename FROM SCOTT.emp e;
/
SELECT DISTINCT o.order_mode FROM OE.orders o;
/
CREATE TABLE OE.orders_hashpart
PARTITION BY HASH (order_id) PARTITIONS 4
AS SELECT * FROM OE.orders;
/
CREATE TABLE SH.sales_rangepart
PARTITION BY RANGE (time_id)
(   PARTITION sales_time_id_pre1999 VALUES LESS THAN (DATE '1999-01-01'),
    PARTITION sales_time_id_1999    VALUES LESS THAN (DATE '2000-01-01'),
    PARTITION sales_time_id_2000    VALUES LESS THAN (DATE '2001-01-01'),
    PARTITION sales_time_id_rest    VALUES LESS THAN (MAXVALUE))
AS SELECT * FROM SH.sales;
/
begin
dbms_stats.gather_table_stats('OE','orders_listpart');
dbms_stats.gather_table_stats('OE','orders_hashpart');
dbms_stats.gather_table_stats('OE','sales_rangepart');
end;
---
select * from dba_part_tables where owner in('OE', 'SH');
---
select * from dba_tab_partitions where table_owner in('OE', 'SH');
---
select * from SH.sales_rangepart s where s.time_id = date'1998-01-10'
select * from SH.sales_rangepart s where s.time_id = date'2001-01-10'

---
begin 
DBMS_MONITOR.SESSION_TRACE_ENABLE;
end;

dbms_output.put_line(scott.topsal(10);
update oe.customers set credit_limit=credit_limit /2;
Delete scott.dept where deptno=40 ;
dbms_monitor.session_trace_disable;

begin
DBMS_MONITOR.SESSION_TRACE_DISABLE;
end;

-----

Rem
Rem $Header: plsql/admin/tracetab.sql /main/8 2018/03/07 03:50:20 stanaya Exp $
Rem
Rem tracetab.sql
Rem
Rem Copyright (c) 1999, 2018, Oracle and/or its affiliates. 
Rem All rights reserved.
Rem
Rem    NAME
Rem      tracetab.sql
Rem
Rem    DESCRIPTION
Rem      Create tables for the PL/SQL tracer
Rem
Rem    NOTES
Rem      This script must be run under SYS
Rem
Rem      The following tables are required to collect data
Rem        plsql_trace_runs - information on trace runs
Rem        plsql_trace_event - detailed trace data
Rem
Rem      For security reasons, these tables are created under SYS, and are
Rem      unique system-wide. The DBA should explicitly grant access to these
Rem      tables to those users who require it.
Rem
Rem      The plsql_trace_runnumber sequence is used for generating unique
Rem      run numbers.
Rem
Rem      THIS SCRIPT DELETES ALL EXISTING DATA!
Rem
Rem    BEGIN SQL_FILE_METADATA
Rem    SQL_SOURCE_FILE: plsql/admin/tracetab.sql
Rem    SQL_SHIPPED_FILE: plsql/admin/tracetab.sql
Rem    SQL_PHASE: UTILITY 
Rem    SQL_STARTUP_MODE: NORMAL
Rem    SQL_IGNORABLE_ERRORS: NONE
Rem    END SQL_FILE_METADATA
Rem    
Rem    
Rem    MODIFIED   (MM/DD/YY)
Rem    jmuller     03/14/06 - Fix bug 5066528: several tracing enhancements 
Rem    dalpern     05/18/05 - 4180912: improved info in PLSQL_TRACE_EVENTS 
Rem    jmuller     10/16/02 - Fix bug 2610154: widen *dblink columns
Rem    astocks     09/16/99 - Make use of sys consistent
Rem    jmuller     10/07/99 - Fix bug 708690: TAB -> blank
Rem    astocks     06/07/99 - Tables for PL/SQL tracer
Rem    astocks     06/07/99 - Created
Rem
Rem

drop table sys.plsql_trace_events cascade constraints;
drop table sys.plsql_trace_runs cascade constraints;

drop sequence sys.plsql_trace_runnumber;

create table sys.plsql_trace_runs
(
  runid           number primary key,  -- unique run identifier,
                                       -- from plsql_trace_runnumber
  run_date        date,                -- start time of run
  run_owner       varchar2(31),        -- account under which run was made
  run_comment     varchar2(2047),      -- user provided comment for this run
  run_comment1    varchar2(2047),      -- additional user-supplied comment
  run_end         date,                -- termination time for this run
  run_flags       varchar2(2047),      -- flags for this run
  related_run     number,              -- for correlating client/server   
  run_system_info varchar2(2047),      -- currently unused
  spare1          varchar2(256)        -- unused
);

comment on table sys.plsql_trace_runs is
        'Run-specific information for the PL/SQL trace';

create table sys.plsql_trace_events
(
  runid           number references sys.plsql_trace_runs,--  run identifier
  event_seq       number,           -- unique sequence number within run
  event_time      date,             -- timestamp
  related_event   number,
  event_kind      number,
  event_unit_dblink varchar2(4000),
  event_unit_owner varchar2(31),
  event_unit      varchar2(31),     -- unit where the event happened
  event_unit_kind varchar2(31),
  event_line      number,           -- line in the unit where event happened
  event_proc_name varchar2(31),     -- if not empty, procedure where event 
                                    -- happened
  stack_depth     number,
--
-- Fields that apply to procedure calls
  proc_name       varchar2(31),     -- if not empty, name of procedure called
  proc_dblink     varchar2(4000),
  proc_owner      varchar2(31),
  proc_unit       varchar2(31),
  proc_unit_kind  varchar2(31),
  proc_line       number,
  proc_params     varchar2(2047),
--
-- Fields that apply to ICDs (Calls to PL/SQL internal routines)
  icd_index       number,         
--
-- Fields that apply to exceptions
  user_excp       number,
  excp            number,
--
-- Field for comments
--     User defined event - text supplied by user
--     SQL event          - actual SQL string
--     Others             - Description of event 
  event_comment   varchar2(2047),
----
-- Fields for bulk binds
-- ?
--
-- Fields from dbms_application_info, dbms_session, and ECID
  module          varchar2(4000),
  action          varchar2(4000),
  client_info     varchar2(4000),
  client_id       varchar2(4000),
  ecid_id         varchar2(4000),
  ecid_seq        number,
--
--
-- Fields for extended callstack and errorstack info
--  (currently set only for "Exception raised", "Exception handled" and "Trace
--  flags changed" ([5066528]) events)
--
  callstack       clob,
  errorstack      clob,
--
  primary key(runid, event_seq)
);

comment on table sys.plsql_trace_events is 
        'Accumulated data from all trace runs';

create sequence sys.plsql_trace_runnumber start with 1 nocache;

grant select on sys.plsql_trace_runs to system;
grant select on sys.plsql_trace_events to system;

-----
select value from v$diag_info where name = 'Default Trace File';
--->
-- tkprf C:\ORACLE\diag\rdbms\trainingglob\trainingglob\trace\trainingglob_ora_3196.trc trace_kl.txt

-----
-----
select * from sys.plsql_trace_runs;
select * from sys.plsql_trace_events

---
BEGIN
    DBMS_TRACE.SET_PLSQL_TRACE(
        DBMS_TRACE.TRACE_ALL_CALLS + 
        DBMS_TRACE.TRACE_ALL_SQL +
        DBMS_TRACE.TRACE_ALL_EXCEPTIONS +
        DBMS_TRACE.TRACE_ALL_LINES);
END;        
/
SELECT * FROM SCOTT.emp e;
SELECT * FROM SCOTT.salgrade sg;
SELECT COUNT(*) FROM SH.costs;
UPDATE OE.customers SET credit_limit = credit_limit / 2;
SELECT * FROM SCOTT.dept d;
DELETE FROM SCOTT.dept WHERE deptno = 40;
SELECT SCOTT.topnsal(10) FROM DUAL;
/
BEGIN
    SCOTT.topnsal_caller;
END;
/
BEGIN
    DBMS_TRACE.CLEAR_PLSQL_TRACE;
END;

----
create directory plshprof_dir as 'c:\Student\Exercises';
begin
  dbms_hprof.start_profiling('plshprof_dir', 'hproftrace1.txt');
end;



 --- 
 ---        számokat összegzõ fuggvény
 CREATE or replace FUNCTION integersum(p_n number) return number is
 s number := 0; i number := 1;  
          BEGIN
            LOOP
              s:= s +i;
              exit when i =p_n;
              i:=i +1 ;
            end loop;
            return s;
           END integersum;
----
 begin
   dbms_output.put_line(integersum(100000));
 end;

alter function integersum compile PLSQL_CODE_TYPE=NATIVE;

/
BEGIN
    DBMS_TRACE.CLEAR_PLSQL_TRACE;
END;
/
SELECT * FROM sys.plsql_trace_runs;
SELECT TO_CHAR(event_time, 'YYYY.MM.DD HH24:MI:SS') FROM sys.plsql_trace_events;
SELECT * FROM sys.plsql_trace_events;
----
create or replace function sh.unit_price (p_quantity_sold number, p_amount_sold number)
RETURN NUMBER IS
BEGIN
 return p_amount_sold / p_quantity_sold;
END;
---
create or replace function sh.unit_price_ch (p_quantity_sold number, p_amount_sold number)
RETURN NUMBER RESULT_CACHE IS
BEGIN
 return p_amount_sold / p_quantity_sold;
END;
---
select avg(sh.unit_price(s.quantity_sold,s.amount_sold)) from sh.sales s
---
select * from V$RESULT_CACHE_OBJECTS where name like '%UNIT_PRICE_R%'
---
with
function unit_price_in(p_quantity_sold number, p_amount_sold number)
RETURN NUMBER IS
BEGIN
 return p_amount_sold / p_quantity_sold;
END;
select avg(unit_price_in(s.quantity_sold,s.amount_sold)) from sh.sales s --- 2.2 sec

-----

SELECT * FROM split(',bbb,cc,d', ',')
a
bbb
cc
d
/
CREATE TYPE t_string_list IS TABLE OF VARCHAR2(100);
/
CREATE OR REPLACE FUNCTION split(p_s VARCHAR2, p_separator VARCHAR2)
RETURN t_string_list IS
    res t_string_list := t_string_list();
BEGIN
    res.EXTEND;
    res(1) := 'abcd';
    RETURN res;
END split;
/
CREATE OR REPLACE FUNCTION split_pipeline(p_s VARCHAR2, p_separator VARCHAR2)
RETURN t_string_list PIPELINED IS
    res t_string_list := t_string_list();
    l_s VARCHAR2(1000);      
    l_pos NUMBER(5);   
    l_temp VARCHAR2(1000);
BEGIN
    l_s := p_s;
    l_pos := INSTR(l_s, p_separator);
    WHILE l_pos > 0 LOOP
        l_temp := SUBSTR(l_s, 1, l_pos - 1); 
        IF LENGTH(l_temp) > 0 THEN
           -- res.EXTEND;            
          -- res(res.LAST) := l_temp;
          PIPE ROW(l_temp);
        END IF;
        l_s := SUBSTR(l_s, l_pos + LENGTH(p_separator));
        l_pos := INSTR(l_s, p_separator);
    END LOOP;
    IF LENGTH(l_s) > 0 THEN
       -- res.EXTEND;        
       -- res(res.LAST) := l_s;
       PIPE ROW(l_s);
    END IF;
    RETURN ;
END split_pipeline;
/
SELECT * FROM TABLE(split_pipeline(',bbb,cc,d', ','));
SELECT * FROM split_pipeline('abc', ',');
SELECT * FROM split_pipeline('abc,,,def,ghi', ',');
SELECT * FROM split_pipeline('abc<sep><sep>def<sep>ghi<sep>', '<sep>');

